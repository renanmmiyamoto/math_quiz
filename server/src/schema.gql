# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateExercises {
  _count: ExercisesCountAggregate
  _max: ExercisesMaxAggregate
  _min: ExercisesMinAggregate
}

type AggregateResults {
  _avg: ResultsAvgAggregate
  _count: ResultsCountAggregate
  _max: ResultsMaxAggregate
  _min: ResultsMinAggregate
  _sum: ResultsSumAggregate
}

type AggregateUsers {
  _count: UsersCountAggregate
  _max: UsersMaxAggregate
  _min: UsersMinAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumOperationTypeFieldUpdateOperationsInput {
  set: OperationType
}

input EnumOperationTypeFilter {
  equals: OperationType
  in: [OperationType!]
  not: NestedEnumOperationTypeFilter
  notIn: [OperationType!]
}

input EnumOperationTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumOperationTypeFilter
  _min: NestedEnumOperationTypeFilter
  equals: OperationType
  in: [OperationType!]
  not: NestedEnumOperationTypeWithAggregatesFilter
  notIn: [OperationType!]
}

type Exercises {
  _count: ExercisesCount
  createdAt: DateTime!
  id: String!
  operation: OperationType!
  results(cursor: ResultsWhereUniqueInput, distinct: [ResultsScalarFieldEnum!], orderBy: [ResultsOrderByWithRelationInput!], skip: Int, take: Int, where: ResultsWhereInput): [Results!]!
  updatedAt: DateTime!
  user: Users!
  userId: String!
}

type ExercisesCount {
  results: Int!
}

type ExercisesCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  operation: Int!
  updatedAt: Int!
  userId: Int!
}

input ExercisesCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  operation: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ExercisesCreateInput {
  createdAt: DateTime
  id: String
  operation: OperationType!
  results: ResultsCreateNestedManyWithoutExerciseInput
  updatedAt: DateTime
  user: UsersCreateNestedOneWithoutExercisesInput!
}

input ExercisesCreateManyInput {
  createdAt: DateTime
  id: String
  operation: OperationType!
  updatedAt: DateTime
  userId: String!
}

input ExercisesCreateManyUserInput {
  createdAt: DateTime
  id: String
  operation: OperationType!
  updatedAt: DateTime
}

input ExercisesCreateManyUserInputEnvelope {
  data: [ExercisesCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ExercisesCreateNestedManyWithoutUserInput {
  connect: [ExercisesWhereUniqueInput!]
  connectOrCreate: [ExercisesCreateOrConnectWithoutUserInput!]
  create: [ExercisesCreateWithoutUserInput!]
  createMany: ExercisesCreateManyUserInputEnvelope
}

input ExercisesCreateNestedOneWithoutResultsInput {
  connect: ExercisesWhereUniqueInput
  connectOrCreate: ExercisesCreateOrConnectWithoutResultsInput
  create: ExercisesCreateWithoutResultsInput
}

input ExercisesCreateOrConnectWithoutResultsInput {
  create: ExercisesCreateWithoutResultsInput!
  where: ExercisesWhereUniqueInput!
}

input ExercisesCreateOrConnectWithoutUserInput {
  create: ExercisesCreateWithoutUserInput!
  where: ExercisesWhereUniqueInput!
}

input ExercisesCreateWithoutResultsInput {
  createdAt: DateTime
  id: String
  operation: OperationType!
  updatedAt: DateTime
  user: UsersCreateNestedOneWithoutExercisesInput!
}

input ExercisesCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  operation: OperationType!
  results: ResultsCreateNestedManyWithoutExerciseInput
  updatedAt: DateTime
}

type ExercisesGroupBy {
  _count: ExercisesCountAggregate
  _max: ExercisesMaxAggregate
  _min: ExercisesMinAggregate
  createdAt: DateTime!
  id: String!
  operation: OperationType!
  updatedAt: DateTime!
  userId: String!
}

input ExercisesListRelationFilter {
  every: ExercisesWhereInput
  none: ExercisesWhereInput
  some: ExercisesWhereInput
}

type ExercisesMaxAggregate {
  createdAt: DateTime
  id: String
  operation: OperationType
  updatedAt: DateTime
  userId: String
}

input ExercisesMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  operation: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type ExercisesMinAggregate {
  createdAt: DateTime
  id: String
  operation: OperationType
  updatedAt: DateTime
  userId: String
}

input ExercisesMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  operation: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ExercisesOrderByRelationAggregateInput {
  _count: SortOrder
}

input ExercisesOrderByWithAggregationInput {
  _count: ExercisesCountOrderByAggregateInput
  _max: ExercisesMaxOrderByAggregateInput
  _min: ExercisesMinOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  operation: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ExercisesOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  operation: SortOrder
  results: ResultsOrderByRelationAggregateInput
  updatedAt: SortOrder
  user: UsersOrderByWithRelationInput
  userId: SortOrder
}

input ExercisesRelationFilter {
  is: ExercisesWhereInput
  isNot: ExercisesWhereInput
}

enum ExercisesScalarFieldEnum {
  createdAt
  id
  operation
  updatedAt
  userId
}

input ExercisesScalarWhereInput {
  AND: [ExercisesScalarWhereInput!]
  NOT: [ExercisesScalarWhereInput!]
  OR: [ExercisesScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  operation: EnumOperationTypeFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input ExercisesScalarWhereWithAggregatesInput {
  AND: [ExercisesScalarWhereWithAggregatesInput!]
  NOT: [ExercisesScalarWhereWithAggregatesInput!]
  OR: [ExercisesScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  operation: EnumOperationTypeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input ExercisesUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  operation: EnumOperationTypeFieldUpdateOperationsInput
  results: ResultsUpdateManyWithoutExerciseInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UsersUpdateOneRequiredWithoutExercisesInput
}

input ExercisesUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  operation: EnumOperationTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ExercisesUpdateManyWithWhereWithoutUserInput {
  data: ExercisesUpdateManyMutationInput!
  where: ExercisesScalarWhereInput!
}

input ExercisesUpdateManyWithoutUserInput {
  connect: [ExercisesWhereUniqueInput!]
  connectOrCreate: [ExercisesCreateOrConnectWithoutUserInput!]
  create: [ExercisesCreateWithoutUserInput!]
  createMany: ExercisesCreateManyUserInputEnvelope
  delete: [ExercisesWhereUniqueInput!]
  deleteMany: [ExercisesScalarWhereInput!]
  disconnect: [ExercisesWhereUniqueInput!]
  set: [ExercisesWhereUniqueInput!]
  update: [ExercisesUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ExercisesUpdateManyWithWhereWithoutUserInput!]
  upsert: [ExercisesUpsertWithWhereUniqueWithoutUserInput!]
}

input ExercisesUpdateOneWithoutResultsInput {
  connect: ExercisesWhereUniqueInput
  connectOrCreate: ExercisesCreateOrConnectWithoutResultsInput
  create: ExercisesCreateWithoutResultsInput
  delete: Boolean
  disconnect: Boolean
  update: ExercisesUpdateWithoutResultsInput
  upsert: ExercisesUpsertWithoutResultsInput
}

input ExercisesUpdateWithWhereUniqueWithoutUserInput {
  data: ExercisesUpdateWithoutUserInput!
  where: ExercisesWhereUniqueInput!
}

input ExercisesUpdateWithoutResultsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  operation: EnumOperationTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UsersUpdateOneRequiredWithoutExercisesInput
}

input ExercisesUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  operation: EnumOperationTypeFieldUpdateOperationsInput
  results: ResultsUpdateManyWithoutExerciseInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ExercisesUpsertWithWhereUniqueWithoutUserInput {
  create: ExercisesCreateWithoutUserInput!
  update: ExercisesUpdateWithoutUserInput!
  where: ExercisesWhereUniqueInput!
}

input ExercisesUpsertWithoutResultsInput {
  create: ExercisesCreateWithoutResultsInput!
  update: ExercisesUpdateWithoutResultsInput!
}

input ExercisesWhereInput {
  AND: [ExercisesWhereInput!]
  NOT: [ExercisesWhereInput!]
  OR: [ExercisesWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  operation: EnumOperationTypeFilter
  results: ResultsListRelationFilter
  updatedAt: DateTimeFilter
  user: UsersRelationFilter
  userId: StringFilter
}

input ExercisesWhereUniqueInput {
  id: String
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createExercises(data: ExercisesCreateInput!): Exercises!
  createManyExercises(data: [ExercisesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyResults(data: [ResultsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUsers(data: [UsersCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createResults(data: ResultsCreateInput!): Results!
  createUsers(data: UsersCreateInput!): Users!
  deleteExercises(where: ExercisesWhereUniqueInput!): Exercises
  deleteManyExercises(where: ExercisesWhereInput): AffectedRowsOutput!
  deleteManyResults(where: ResultsWhereInput): AffectedRowsOutput!
  deleteManyUsers(where: UsersWhereInput): AffectedRowsOutput!
  deleteResults(where: ResultsWhereUniqueInput!): Results
  deleteUsers(where: UsersWhereUniqueInput!): Users
  updateExercises(data: ExercisesUpdateInput!, where: ExercisesWhereUniqueInput!): Exercises
  updateManyExercises(data: ExercisesUpdateManyMutationInput!, where: ExercisesWhereInput): AffectedRowsOutput!
  updateManyResults(data: ResultsUpdateManyMutationInput!, where: ResultsWhereInput): AffectedRowsOutput!
  updateManyUsers(data: UsersUpdateManyMutationInput!, where: UsersWhereInput): AffectedRowsOutput!
  updateResults(data: ResultsUpdateInput!, where: ResultsWhereUniqueInput!): Results
  updateUsers(data: UsersUpdateInput!, where: UsersWhereUniqueInput!): Users
  upsertExercises(create: ExercisesCreateInput!, update: ExercisesUpdateInput!, where: ExercisesWhereUniqueInput!): Exercises!
  upsertResults(create: ResultsCreateInput!, update: ResultsUpdateInput!, where: ResultsWhereUniqueInput!): Results!
  upsertUsers(create: UsersCreateInput!, update: UsersUpdateInput!, where: UsersWhereUniqueInput!): Users!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumOperationTypeFilter {
  equals: OperationType
  in: [OperationType!]
  not: NestedEnumOperationTypeFilter
  notIn: [OperationType!]
}

input NestedEnumOperationTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumOperationTypeFilter
  _min: NestedEnumOperationTypeFilter
  equals: OperationType
  in: [OperationType!]
  not: NestedEnumOperationTypeWithAggregatesFilter
  notIn: [OperationType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

enum OperationType {
  ADDITION
  DIVISION
  EQUATION
  EXPONENTIATION
  MULTIPLICATION
  ROOTING
  SUBTRACTION
}

type Query {
  aggregateExercises(cursor: ExercisesWhereUniqueInput, orderBy: [ExercisesOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisesWhereInput): AggregateExercises!
  aggregateResults(cursor: ResultsWhereUniqueInput, orderBy: [ResultsOrderByWithRelationInput!], skip: Int, take: Int, where: ResultsWhereInput): AggregateResults!
  aggregateUsers(cursor: UsersWhereUniqueInput, orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): AggregateUsers!
  findFirstExercises(cursor: ExercisesWhereUniqueInput, distinct: [ExercisesScalarFieldEnum!], orderBy: [ExercisesOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisesWhereInput): Exercises
  findFirstResults(cursor: ResultsWhereUniqueInput, distinct: [ResultsScalarFieldEnum!], orderBy: [ResultsOrderByWithRelationInput!], skip: Int, take: Int, where: ResultsWhereInput): Results
  findFirstUsers(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): Users
  findManyExercises(cursor: ExercisesWhereUniqueInput, distinct: [ExercisesScalarFieldEnum!], orderBy: [ExercisesOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisesWhereInput): [Exercises!]!
  findManyResults(cursor: ResultsWhereUniqueInput, distinct: [ResultsScalarFieldEnum!], orderBy: [ResultsOrderByWithRelationInput!], skip: Int, take: Int, where: ResultsWhereInput): [Results!]!
  findManyUsers(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): [Users!]!
  findUniqueExercises(where: ExercisesWhereUniqueInput!): Exercises
  findUniqueResults(where: ResultsWhereUniqueInput!): Results
  findUniqueUsers(where: UsersWhereUniqueInput!): Users
  groupByExercises(by: [ExercisesScalarFieldEnum!]!, having: ExercisesScalarWhereWithAggregatesInput, orderBy: [ExercisesOrderByWithAggregationInput!], skip: Int, take: Int, where: ExercisesWhereInput): [ExercisesGroupBy!]!
  groupByResults(by: [ResultsScalarFieldEnum!]!, having: ResultsScalarWhereWithAggregatesInput, orderBy: [ResultsOrderByWithAggregationInput!], skip: Int, take: Int, where: ResultsWhereInput): [ResultsGroupBy!]!
  groupByUsers(by: [UsersScalarFieldEnum!]!, having: UsersScalarWhereWithAggregatesInput, orderBy: [UsersOrderByWithAggregationInput!], skip: Int, take: Int, where: UsersWhereInput): [UsersGroupBy!]!
}

enum QueryMode {
  default
  insensitive
}

type Results {
  calculation: String!
  createdAt: DateTime!
  duration: Int!
  effort: Int!
  exercise: Exercises
  exerciseId: String
  id: String!
  isCorrect: Boolean!
  operation: OperationType!
  response: String!
  trueResponse: String!
  updatedAt: DateTime!
}

type ResultsAvgAggregate {
  duration: Float
  effort: Float
}

input ResultsAvgOrderByAggregateInput {
  duration: SortOrder
  effort: SortOrder
}

type ResultsCountAggregate {
  _all: Int!
  calculation: Int!
  createdAt: Int!
  duration: Int!
  effort: Int!
  exerciseId: Int!
  id: Int!
  isCorrect: Int!
  operation: Int!
  response: Int!
  trueResponse: Int!
  updatedAt: Int!
}

input ResultsCountOrderByAggregateInput {
  calculation: SortOrder
  createdAt: SortOrder
  duration: SortOrder
  effort: SortOrder
  exerciseId: SortOrder
  id: SortOrder
  isCorrect: SortOrder
  operation: SortOrder
  response: SortOrder
  trueResponse: SortOrder
  updatedAt: SortOrder
}

input ResultsCreateInput {
  calculation: String!
  createdAt: DateTime
  duration: Int!
  effort: Int!
  exercise: ExercisesCreateNestedOneWithoutResultsInput
  id: String
  isCorrect: Boolean!
  operation: OperationType!
  response: String!
  trueResponse: String!
  updatedAt: DateTime
}

input ResultsCreateManyExerciseInput {
  calculation: String!
  createdAt: DateTime
  duration: Int!
  effort: Int!
  id: String
  isCorrect: Boolean!
  operation: OperationType!
  response: String!
  trueResponse: String!
  updatedAt: DateTime
}

input ResultsCreateManyExerciseInputEnvelope {
  data: [ResultsCreateManyExerciseInput!]!
  skipDuplicates: Boolean
}

input ResultsCreateManyInput {
  calculation: String!
  createdAt: DateTime
  duration: Int!
  effort: Int!
  exerciseId: String
  id: String
  isCorrect: Boolean!
  operation: OperationType!
  response: String!
  trueResponse: String!
  updatedAt: DateTime
}

input ResultsCreateNestedManyWithoutExerciseInput {
  connect: [ResultsWhereUniqueInput!]
  connectOrCreate: [ResultsCreateOrConnectWithoutExerciseInput!]
  create: [ResultsCreateWithoutExerciseInput!]
  createMany: ResultsCreateManyExerciseInputEnvelope
}

input ResultsCreateOrConnectWithoutExerciseInput {
  create: ResultsCreateWithoutExerciseInput!
  where: ResultsWhereUniqueInput!
}

input ResultsCreateWithoutExerciseInput {
  calculation: String!
  createdAt: DateTime
  duration: Int!
  effort: Int!
  id: String
  isCorrect: Boolean!
  operation: OperationType!
  response: String!
  trueResponse: String!
  updatedAt: DateTime
}

type ResultsGroupBy {
  _avg: ResultsAvgAggregate
  _count: ResultsCountAggregate
  _max: ResultsMaxAggregate
  _min: ResultsMinAggregate
  _sum: ResultsSumAggregate
  calculation: String!
  createdAt: DateTime!
  duration: Int!
  effort: Int!
  exerciseId: String
  id: String!
  isCorrect: Boolean!
  operation: OperationType!
  response: String!
  trueResponse: String!
  updatedAt: DateTime!
}

input ResultsListRelationFilter {
  every: ResultsWhereInput
  none: ResultsWhereInput
  some: ResultsWhereInput
}

type ResultsMaxAggregate {
  calculation: String
  createdAt: DateTime
  duration: Int
  effort: Int
  exerciseId: String
  id: String
  isCorrect: Boolean
  operation: OperationType
  response: String
  trueResponse: String
  updatedAt: DateTime
}

input ResultsMaxOrderByAggregateInput {
  calculation: SortOrder
  createdAt: SortOrder
  duration: SortOrder
  effort: SortOrder
  exerciseId: SortOrder
  id: SortOrder
  isCorrect: SortOrder
  operation: SortOrder
  response: SortOrder
  trueResponse: SortOrder
  updatedAt: SortOrder
}

type ResultsMinAggregate {
  calculation: String
  createdAt: DateTime
  duration: Int
  effort: Int
  exerciseId: String
  id: String
  isCorrect: Boolean
  operation: OperationType
  response: String
  trueResponse: String
  updatedAt: DateTime
}

input ResultsMinOrderByAggregateInput {
  calculation: SortOrder
  createdAt: SortOrder
  duration: SortOrder
  effort: SortOrder
  exerciseId: SortOrder
  id: SortOrder
  isCorrect: SortOrder
  operation: SortOrder
  response: SortOrder
  trueResponse: SortOrder
  updatedAt: SortOrder
}

input ResultsOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResultsOrderByWithAggregationInput {
  _avg: ResultsAvgOrderByAggregateInput
  _count: ResultsCountOrderByAggregateInput
  _max: ResultsMaxOrderByAggregateInput
  _min: ResultsMinOrderByAggregateInput
  _sum: ResultsSumOrderByAggregateInput
  calculation: SortOrder
  createdAt: SortOrder
  duration: SortOrder
  effort: SortOrder
  exerciseId: SortOrder
  id: SortOrder
  isCorrect: SortOrder
  operation: SortOrder
  response: SortOrder
  trueResponse: SortOrder
  updatedAt: SortOrder
}

input ResultsOrderByWithRelationInput {
  calculation: SortOrder
  createdAt: SortOrder
  duration: SortOrder
  effort: SortOrder
  exercise: ExercisesOrderByWithRelationInput
  exerciseId: SortOrder
  id: SortOrder
  isCorrect: SortOrder
  operation: SortOrder
  response: SortOrder
  trueResponse: SortOrder
  updatedAt: SortOrder
}

enum ResultsScalarFieldEnum {
  calculation
  createdAt
  duration
  effort
  exerciseId
  id
  isCorrect
  operation
  response
  trueResponse
  updatedAt
}

input ResultsScalarWhereInput {
  AND: [ResultsScalarWhereInput!]
  NOT: [ResultsScalarWhereInput!]
  OR: [ResultsScalarWhereInput!]
  calculation: StringFilter
  createdAt: DateTimeFilter
  duration: IntFilter
  effort: IntFilter
  exerciseId: StringNullableFilter
  id: StringFilter
  isCorrect: BoolFilter
  operation: EnumOperationTypeFilter
  response: StringFilter
  trueResponse: StringFilter
  updatedAt: DateTimeFilter
}

input ResultsScalarWhereWithAggregatesInput {
  AND: [ResultsScalarWhereWithAggregatesInput!]
  NOT: [ResultsScalarWhereWithAggregatesInput!]
  OR: [ResultsScalarWhereWithAggregatesInput!]
  calculation: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  duration: IntWithAggregatesFilter
  effort: IntWithAggregatesFilter
  exerciseId: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  isCorrect: BoolWithAggregatesFilter
  operation: EnumOperationTypeWithAggregatesFilter
  response: StringWithAggregatesFilter
  trueResponse: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ResultsSumAggregate {
  duration: Int
  effort: Int
}

input ResultsSumOrderByAggregateInput {
  duration: SortOrder
  effort: SortOrder
}

input ResultsUpdateInput {
  calculation: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: IntFieldUpdateOperationsInput
  effort: IntFieldUpdateOperationsInput
  exercise: ExercisesUpdateOneWithoutResultsInput
  id: StringFieldUpdateOperationsInput
  isCorrect: BoolFieldUpdateOperationsInput
  operation: EnumOperationTypeFieldUpdateOperationsInput
  response: StringFieldUpdateOperationsInput
  trueResponse: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ResultsUpdateManyMutationInput {
  calculation: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: IntFieldUpdateOperationsInput
  effort: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  isCorrect: BoolFieldUpdateOperationsInput
  operation: EnumOperationTypeFieldUpdateOperationsInput
  response: StringFieldUpdateOperationsInput
  trueResponse: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ResultsUpdateManyWithWhereWithoutExerciseInput {
  data: ResultsUpdateManyMutationInput!
  where: ResultsScalarWhereInput!
}

input ResultsUpdateManyWithoutExerciseInput {
  connect: [ResultsWhereUniqueInput!]
  connectOrCreate: [ResultsCreateOrConnectWithoutExerciseInput!]
  create: [ResultsCreateWithoutExerciseInput!]
  createMany: ResultsCreateManyExerciseInputEnvelope
  delete: [ResultsWhereUniqueInput!]
  deleteMany: [ResultsScalarWhereInput!]
  disconnect: [ResultsWhereUniqueInput!]
  set: [ResultsWhereUniqueInput!]
  update: [ResultsUpdateWithWhereUniqueWithoutExerciseInput!]
  updateMany: [ResultsUpdateManyWithWhereWithoutExerciseInput!]
  upsert: [ResultsUpsertWithWhereUniqueWithoutExerciseInput!]
}

input ResultsUpdateWithWhereUniqueWithoutExerciseInput {
  data: ResultsUpdateWithoutExerciseInput!
  where: ResultsWhereUniqueInput!
}

input ResultsUpdateWithoutExerciseInput {
  calculation: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: IntFieldUpdateOperationsInput
  effort: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  isCorrect: BoolFieldUpdateOperationsInput
  operation: EnumOperationTypeFieldUpdateOperationsInput
  response: StringFieldUpdateOperationsInput
  trueResponse: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ResultsUpsertWithWhereUniqueWithoutExerciseInput {
  create: ResultsCreateWithoutExerciseInput!
  update: ResultsUpdateWithoutExerciseInput!
  where: ResultsWhereUniqueInput!
}

input ResultsWhereInput {
  AND: [ResultsWhereInput!]
  NOT: [ResultsWhereInput!]
  OR: [ResultsWhereInput!]
  calculation: StringFilter
  createdAt: DateTimeFilter
  duration: IntFilter
  effort: IntFilter
  exercise: ExercisesRelationFilter
  exerciseId: StringNullableFilter
  id: StringFilter
  isCorrect: BoolFilter
  operation: EnumOperationTypeFilter
  response: StringFilter
  trueResponse: StringFilter
  updatedAt: DateTimeFilter
}

input ResultsWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Users {
  _count: UsersCount
  bornDate: DateTime!
  createdAt: DateTime!
  email: String!
  exercises(cursor: ExercisesWhereUniqueInput, distinct: [ExercisesScalarFieldEnum!], orderBy: [ExercisesOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisesWhereInput): [Exercises!]!
  id: String!
  name: String!
  updatedAt: DateTime!
}

type UsersCount {
  exercises: Int!
}

type UsersCountAggregate {
  _all: Int!
  bornDate: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input UsersCountOrderByAggregateInput {
  bornDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UsersCreateInput {
  bornDate: DateTime!
  createdAt: DateTime
  email: String!
  exercises: ExercisesCreateNestedManyWithoutUserInput
  id: String
  name: String!
  updatedAt: DateTime
}

input UsersCreateManyInput {
  bornDate: DateTime!
  createdAt: DateTime
  email: String!
  id: String
  name: String!
  updatedAt: DateTime
}

input UsersCreateNestedOneWithoutExercisesInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutExercisesInput
  create: UsersCreateWithoutExercisesInput
}

input UsersCreateOrConnectWithoutExercisesInput {
  create: UsersCreateWithoutExercisesInput!
  where: UsersWhereUniqueInput!
}

input UsersCreateWithoutExercisesInput {
  bornDate: DateTime!
  createdAt: DateTime
  email: String!
  id: String
  name: String!
  updatedAt: DateTime
}

type UsersGroupBy {
  _count: UsersCountAggregate
  _max: UsersMaxAggregate
  _min: UsersMinAggregate
  bornDate: DateTime!
  createdAt: DateTime!
  email: String!
  id: String!
  name: String!
  updatedAt: DateTime!
}

type UsersMaxAggregate {
  bornDate: DateTime
  createdAt: DateTime
  email: String
  id: String
  name: String
  updatedAt: DateTime
}

input UsersMaxOrderByAggregateInput {
  bornDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type UsersMinAggregate {
  bornDate: DateTime
  createdAt: DateTime
  email: String
  id: String
  name: String
  updatedAt: DateTime
}

input UsersMinOrderByAggregateInput {
  bornDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UsersOrderByWithAggregationInput {
  _count: UsersCountOrderByAggregateInput
  _max: UsersMaxOrderByAggregateInput
  _min: UsersMinOrderByAggregateInput
  bornDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UsersOrderByWithRelationInput {
  bornDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  exercises: ExercisesOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UsersRelationFilter {
  is: UsersWhereInput
  isNot: UsersWhereInput
}

enum UsersScalarFieldEnum {
  bornDate
  createdAt
  email
  id
  name
  updatedAt
}

input UsersScalarWhereWithAggregatesInput {
  AND: [UsersScalarWhereWithAggregatesInput!]
  NOT: [UsersScalarWhereWithAggregatesInput!]
  OR: [UsersScalarWhereWithAggregatesInput!]
  bornDate: DateTimeWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UsersUpdateInput {
  bornDate: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  exercises: ExercisesUpdateManyWithoutUserInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UsersUpdateManyMutationInput {
  bornDate: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UsersUpdateOneRequiredWithoutExercisesInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutExercisesInput
  create: UsersCreateWithoutExercisesInput
  update: UsersUpdateWithoutExercisesInput
  upsert: UsersUpsertWithoutExercisesInput
}

input UsersUpdateWithoutExercisesInput {
  bornDate: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UsersUpsertWithoutExercisesInput {
  create: UsersCreateWithoutExercisesInput!
  update: UsersUpdateWithoutExercisesInput!
}

input UsersWhereInput {
  AND: [UsersWhereInput!]
  NOT: [UsersWhereInput!]
  OR: [UsersWhereInput!]
  bornDate: DateTimeFilter
  createdAt: DateTimeFilter
  email: StringFilter
  exercises: ExercisesListRelationFilter
  id: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input UsersWhereUniqueInput {
  email: String
  id: String
}
